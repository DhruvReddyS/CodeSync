# CodeSync Backend - Complete Firebase Data Storage Analysis

## Executive Summary

Your backend stores data in **Firestore (NoSQL)** with the following structure:

1. **users** - Instructor/admin accounts
2. **instructors** - Instructor login credentials  
3. **students** - Student profiles with coding platform data

**Key Issue**: Mixed data storage patterns with redundant fields and unclear separation of concerns. This analysis provides recommendations for better organization.

---

## 1. CURRENT DATA STORAGE PATTERNS

### 1.1 User Authentication Flow

#### Student Login (Google OAuth)
```
POST /api/auth/student/google
â”‚
â”œâ”€ Verify Firebase ID token
â”‚
â”œâ”€ Create/Update in users/{firebaseUid}
â”‚  â”œâ”€â”€ firebaseUid: string (from Google)
â”‚  â”œâ”€â”€ email: string
â”‚  â”œâ”€â”€ name: string
â”‚  â”œâ”€â”€ photoURL: string
â”‚  â”œâ”€â”€ role: "student"
â”‚  â”œâ”€â”€ createdAt: Timestamp
â”‚  â””â”€â”€ updatedAt: Timestamp
â”‚
â””â”€ Create/Update in students/{firebaseUid}
   â”œâ”€â”€ userId: string (same as key)
   â”œâ”€â”€ createdAt: Timestamp
   â””â”€â”€ updatedAt: Timestamp
```

**Issue**: `users/{firebaseUid}` and `students/{firebaseUid}` have duplicated userId references.

#### Instructor Login (Email/Password)
```
POST /api/auth/instructor/register
â”‚
â”œâ”€ Create in users/{autoGeneratedId}
â”‚  â”œâ”€â”€ email: string
â”‚  â”œâ”€â”€ name: string
â”‚  â”œâ”€â”€ role: "instructor"
â”‚  â”œâ”€â”€ firebaseUid: null (NOT used for instructors)
â”‚  â”œâ”€â”€ createdAt: Timestamp
â”‚  â””â”€â”€ updatedAt: Timestamp
â”‚
â””â”€ Create in instructors/{userId}
   â”œâ”€â”€ userId: string (links to users doc)
   â”œâ”€â”€ passwordHash: string (bcryptjs)
   â”œâ”€â”€ createdAt: Timestamp
   â””â”€â”€ updatedAt: Timestamp
```

**Issue**: Two collections (`users` + `instructors`) for what is one concept. Mixing authentication (users) with password credentials (instructors).

---

### 1.2 Student Profile Storage

#### Main Student Document
**Path**: `students/{studentId}`

```json
{
  "userId": "string",
  "fullName": "string",
  "collegeEmail": "string | null",
  "personalEmail": "string | null",
  "phone": "string | null",
  "branch": "string",
  "yearOfStudy": "string",
  "year": "string",          // âš ï¸ DUPLICATE of yearOfStudy
  "section": "string",
  "rollNumber": "string",
  "graduationYear": "string",
  "profile": {               // Custom profile metadata
    "bio": "string",
    "skills": ["string"],
    // ... any custom fields
  },
  "cpHandles": {
    "leetcode": "string | null",
    "codeforces": "string | null",
    "codechef": "string | null",
    "github": "string | null",
    "hackerrank": "string | null",
    "atcoder": "string | null"
  },
  "cpScores": {
    "codeSyncScore": "number",        // Raw sum score
    "displayScore": "number",         // 0-100 scale
    "totalProblemsSolved": "number",
    "platformSkills": {
      "leetcode": "number",
      "codeforces": "number",
      "codechef": "number",
      "github": "number",
      "hackerrank": "number",
      "atcoder": "number"
    },
    "breakdown": {
      "leetcode": {
        "problemsSolved": "number",
        "rating": "number",
        "contests": "number"
      },
      // ... per platform
    },
    "lastComputedAt": "Timestamp",
    "updatedAt": "Timestamp"
  },
  "onboardingCompleted": "boolean",
  "lastActiveAt": "Timestamp | null",
  "createdAt": "Timestamp",
  "updatedAt": "Timestamp"
}
```

#### Platform Profiles Sub-Collection
**Path**: `students/{studentId}/cpProfiles/{platform}`

Each platform doc stores scraped data:

```json
{
  "platform": "leetcode",
  "handle": "username",
  
  // LeetCode specific
  "totalSolved": 150,
  "solvedEasy": 50,
  "solvedMedium": 80,
  "solvedHard": 20,
  "streak": 42,
  "acceptanceRate": 45.5,
  "contestRating": 1500,
  "globalRanking": 12345,
  "attendedContests": 8,
  "topPercentage": 15.5,
  "topicWiseProblemCounts": [{...}],
  "contestHistory": [{...}],
  "recentSubmissions": [{...}],
  "languages": { "python": 80, "cpp": 70 },
  "badges": 5,
  "profileUrl": "https://leetcode.com/u/username/",
  
  // Timestamps
  "lastScrapedAt": "Timestamp",
  "updatedAt": "Timestamp"
}
```

Similar structure for: codeforces, codechef, github, hackerrank, atcoder (each with platform-specific fields).

---

## 2. DATA FLOW ANALYSIS

### 2.1 User Registration & Onboarding

```
1. Google Login
   â†“
2. POST /api/auth/student/google
   â”œâ”€ Verify Firebase token
   â”œâ”€ Create users/{firebaseUid}
   â”œâ”€ Create students/{firebaseUid}
   â””â”€ Return JWT token (sub = firebaseUid)
   â†“
3. Frontend calls POST /api/student/onboarding
   â”œâ”€ Auth middleware verifies JWT
   â”œâ”€ Extracts studentId from JWT (sub field)
   â”œâ”€ Updates students/{studentId} with profile
   â”œâ”€ Updates cpHandles field
   â””â”€ Triggers refreshStudentCPData() if handles provided
   â†“
4. refreshStudentCPData() kicks off scrapers
   â”œâ”€ Loads cpHandles from students/{studentId}
   â”œâ”€ For each platform with a handle:
   â”‚  â”œâ”€ Call scraper (GitHub API, LeetCode GraphQL, etc.)
   â”‚  â”œâ”€ Save to students/{studentId}/cpProfiles/{platform}
   â”‚  â””â”€ Store: handle, stats, lastScrapedAt
   â””â”€ Compute cpScores from all platforms
     â””â”€ Save computed scores to students/{studentId}.cpScores
```

### 2.2 Scoring System

**Stored In**: `students/{studentId}.cpScores`

**Computed From**: `students/{studentId}/cpProfiles/*` (all platform docs)

**Computation Happens At**:
- During onboarding (first time)
- When user updates cpHandles (`PATCH /api/student/cp-handles`)
- When scraper completes (`POST /api/student/stats/refresh-all`)
- By admin/instructor refresh

**Score Calculation**:
```typescript
// Per-platform scoring
LeetCode:  solved*10 + rating*1.0 + contests*25
CodeForces: solved*12 + rating*1.2 + contests*40
CodeChef:  fullySolved*12 + partiallySolved*4 + rating + estContests*30
HackerRank: problems*8 + contests*20 + badges*40 + certs*60
GitHub:    contributions*2 + stars*30 + repos*10 + followers*20
AtCoder:   solved*8 + rating*1.2 + contests*35

// Final score
platformSkills = { leetcode: score1, codeforces: score2, ... }
codeSyncScore = sum(platformSkills.values)
displayScore = Math.round(codeSyncScore)  // 0-100 scale after normalization
```

---

## 3. IDENTIFIED ISSUES & PROBLEMS

### ðŸ”´ **Issue 1: Duplicate Year Fields**
```typescript
// In students/{studentId}
yearOfStudy: "2024"  // Primary
year: "2024"         // Duplicate copy
```

**Impact**: Risk of sync issues, confusing API contracts
**Fix**: Use only `yearOfStudy` (or rename consistently)

---

### ðŸ”´ **Issue 2: Redundant UserId Field**
```typescript
// In students/{studentId}
{
  userId: "same-as-document-key",  // Redundant!
  // ...
}
```

**Impact**: Extra storage, confusing queries
**Fix**: Remove `userId` field - use document key instead

---

### ðŸ”´ **Issue 3: Mixed Authentication Models**

Current approach:
- Students: use Firebase Authentication (OAuth)
- Instructors: custom email/password in Firestore

Problems:
- Instructors not integrated with Firebase Auth
- Password hashing/comparison done manually
- Inconsistent auth flows

**Recommendation**: 
- Option A: Create instructors in Firebase Auth too (better)
- Option B: Keep custom auth but improve security (add salt validation, rate limiting)

---

### ðŸ”´ **Issue 4: Data Organization - Users Collection Not Fully Utilized**

Current state:
```
users/{firebaseUid}          // Some basic info
instructors/{userId}         // Password only
students/{studentId}         // Full profile + everything
```

Problem: 
- Students document duplicates data in `users` collection
- No single "user record" pattern
- Mixed responsibility: students doc has profile + stats + scores

**Better Approach**:
```
users/{userId}
â”œâ”€ email
â”œâ”€ name
â”œâ”€ role: "student" | "instructor"
â”œâ”€ photoURL
â”œâ”€ createdAt
â””â”€ updatedAt

students/{studentId}  (extends user)
â”œâ”€ fullName
â”œâ”€ contact info (phone, emails)
â”œâ”€ academic info (branch, year, section, rollNumber)
â”œâ”€ profile (bio, skills)
â””â”€ cpHandles

studentStats/{studentId}
â”œâ”€ cpScores
â”œâ”€ platformStats (or load from sub-collection)
â””â”€ updatedAt

instructors/{instructorId}
â”œâ”€ passwordHash (if custom auth)
â”œâ”€ department (if applicable)
â””â”€ createdAt
```

---

### ðŸ”´ **Issue 5: Score Denormalization**

Currently:
```
students/{studentId}
â”œâ”€ cpScores (cached computed values)
â””â”€ cpProfiles/ (raw data)
```

Questions:
- When is `cpScores` updated? (Seems to happen after scraping)
- What if scraping fails? (Scores get stale)
- How often are scores computed? (No TTL/refresh strategy defined)

**Better Pattern**:
```typescript
// Option 1: Keep denormalized, but add refresh timestamp
students/{studentId}.cpScores = {
  displayScore: 85,
  lastComputedAt: Timestamp,
  expiresAt: Timestamp (optional - 7 days from lastComputedAt),
  // ...
}

// Option 2: Query-time computation (slower but always fresh)
// On /stats/me endpoint, recompute from cpProfiles sub-collection

// Option 3: Hybrid (recommended)
// - Store computed scores for fast dashboard queries
// - Add refresh endpoint for manual updates
// - Implement background job for periodic recomputation
```

---

### ðŸ”´ **Issue 6: Timestamp Inconsistency**

Different timestamp patterns used:
```typescript
// In students doc
createdAt: Timestamp         // Firebase server timestamp âœ“
updatedAt: Timestamp         // Firebase server timestamp âœ“
lastActiveAt: Timestamp      // Could be null

// In cpProfiles doc
lastScrapedAt: Timestamp     // When scraper ran
updatedAt: Timestamp         // ?

// In cpScores object
lastComputedAt: Timestamp    // When scores computed
updatedAt: Timestamp         // (nested in cpScores)
```

**Better Pattern**:
```typescript
// Clear naming convention
document: {
  createdAt: Timestamp      // Initial creation
  updatedAt: Timestamp      // Last modification
  deletedAt?: Timestamp     // Soft delete (optional)
}

// For computed data
cpScores: {
  displayScore: number
  computedAt: Timestamp     // Renamed from lastComputedAt
  expiresAt?: Timestamp     // When recomputation needed
}

// For external data
cpProfiles/{platform}: {
  scrapedAt: Timestamp      // Renamed from lastScrapedAt
  expiresAt?: Timestamp     // When next scrape needed
}
```

---

### ðŸ”´ **Issue 7: Missing Indexes**

Firestore queries used (no composite indexes defined):
```typescript
// In auth.routes.ts
usersCol.where("email", "==", email).where("role", "==", "instructor")

// In instructor.routes.ts
studentsCol
  .where("branch", "==", branch)
  .where("section", "==", section)
  .where("yearOfStudy", "==", year)
  .limit(limit)
  .get()
```

**Firestore will auto-create indexes**, but you should explicitly define them in `firestore.indexes.json`:

```json
{
  "indexes": [
    {
      "collectionGroup": "users",
      "queryScope": "Collection",
      "fields": [
        { "fieldPath": "email", "order": "ASCENDING" },
        { "fieldPath": "role", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "students",
      "queryScope": "Collection",
      "fields": [
        { "fieldPath": "branch", "order": "ASCENDING" },
        { "fieldPath": "section", "order": "ASCENDING" },
        { "fieldPath": "yearOfStudy", "order": "ASCENDING" }
      ]
    }
  ]
}
```

---

### ðŸ”´ **Issue 8: No Soft Delete / Archive Pattern**

If a student leaves or is removed, data is permanently deleted. No audit trail.

**Recommendation**:
```typescript
students/{studentId}: {
  // ... fields
  status: "active" | "inactive" | "deleted"
  deletedAt?: Timestamp
  deletedBy?: string      // Who deleted it
  deletionReason?: string
}
```

---

## 4. RECOMMENDED FIRESTORE SCHEMA REDESIGN

### New Structure

```
firestore/
â”œâ”€â”€ users/
â”‚   â””â”€â”€ {userId}
â”‚       â”œâ”€â”€ email: string
â”‚       â”œâ”€â”€ name: string
â”‚       â”œâ”€â”€ role: "student" | "instructor"
â”‚       â”œâ”€â”€ photoURL?: string
â”‚       â”œâ”€â”€ firebaseUid?: string (only for OAuth users)
â”‚       â”œâ”€â”€ status: "active" | "inactive" | "deleted"
â”‚       â”œâ”€â”€ createdAt: Timestamp
â”‚       â”œâ”€â”€ updatedAt: Timestamp
â”‚       â””â”€â”€ deletedAt?: Timestamp
â”‚
â”œâ”€â”€ students/
â”‚   â””â”€â”€ {studentId}
â”‚       â”œâ”€â”€ // Basic profile
â”‚       â”œâ”€â”€ fullName: string
â”‚       â”œâ”€â”€ collegeEmail?: string
â”‚       â”œâ”€â”€ personalEmail?: string
â”‚       â”œâ”€â”€ phone?: string
â”‚       â”‚
â”‚       â”œâ”€â”€ // Academic info
â”‚       â”œâ”€â”€ branch: string
â”‚       â”œâ”€â”€ yearOfStudy: string
â”‚       â”œâ”€â”€ section: string
â”‚       â”œâ”€â”€ rollNumber: string
â”‚       â”œâ”€â”€ graduationYear?: string
â”‚       â”‚
â”‚       â”œâ”€â”€ // Custom profile
â”‚       â”œâ”€â”€ profile?: {
â”‚       â”‚   bio?: string
â”‚       â”‚   skills?: string[]
â”‚       â”‚   // ... custom fields
â”‚       â”‚ }
â”‚       â”‚
â”‚       â”œâ”€â”€ // Coding handles
â”‚       â”œâ”€â”€ cpHandles: {
â”‚       â”‚   leetcode?: string
â”‚       â”‚   codeforces?: string
â”‚       â”‚   codechef?: string
â”‚       â”‚   github?: string
â”‚       â”‚   hackerrank?: string
â”‚       â”‚   atcoder?: string
â”‚       â”‚ }
â”‚       â”‚
â”‚       â”œâ”€â”€ // Metadata
â”‚       â”œâ”€â”€ onboardingCompleted: boolean
â”‚       â”œâ”€â”€ lastActiveAt?: Timestamp
â”‚       â”œâ”€â”€ createdAt: Timestamp
â”‚       â”œâ”€â”€ updatedAt: Timestamp
â”‚       â”‚
â”‚       â””â”€â”€ cpProfiles/  (sub-collection)
â”‚           â”œâ”€â”€ leetcode/
â”‚           â”‚   â”œâ”€â”€ platform: "leetcode"
â”‚           â”‚   â”œâ”€â”€ handle: string
â”‚           â”‚   â”œâ”€â”€ // ... platform-specific stats
â”‚           â”‚   â”œâ”€â”€ scrapedAt: Timestamp
â”‚           â”‚   â””â”€â”€ expiresAt?: Timestamp
â”‚           â”‚
â”‚           â”œâ”€â”€ codeforces/
â”‚           â”œâ”€â”€ codechef/
â”‚           â”œâ”€â”€ github/
â”‚           â”œâ”€â”€ hackerrank/
â”‚           â””â”€â”€ atcoder/
â”‚
â”œâ”€â”€ studentScores/   (NEW - separate collection)
â”‚   â””â”€â”€ {studentId}
â”‚       â”œâ”€â”€ displayScore: number
â”‚       â”œâ”€â”€ platformSkills: {
â”‚       â”‚   leetcode: number
â”‚       â”‚   codeforces: number
â”‚       â”‚   // ...
â”‚       â”‚ }
â”‚       â”œâ”€â”€ totalProblemsSolved: number
â”‚       â”œâ”€â”€ breakdown?: { ... }
â”‚       â”œâ”€â”€ computedAt: Timestamp
â”‚       â”œâ”€â”€ expiresAt: Timestamp  (e.g., 7 days from computedAt)
â”‚       â””â”€â”€ version: number  (for cache invalidation)
â”‚
â””â”€â”€ instructors/
    â””â”€â”€ {instructorId}
        â”œâ”€â”€ passwordHash?: string  (if custom auth)
        â”œâ”€â”€ department?: string
        â”œâ”€â”€ createdAt: Timestamp
        â””â”€â”€ updatedAt: Timestamp
```

### Schema Improvements

**1. Separate Concerns**
- `users` - shared auth/identity
- `students` - student-specific profile
- `studentScores` - computed analytics (fast queries)
- `instructors` - instructor-specific fields

**2. Clear Field Purposes**
- Remove duplicate fields (userId, year, etc.)
- Use consistent timestamp naming
- Add status field for soft deletes

**3. Indexing Strategy**
```json
{
  "indexes": [
    {
      "collectionGroup": "users",
      "fields": [
        { "fieldPath": "email", "order": "ASCENDING" },
        { "fieldPath": "role", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "users",
      "fields": [
        { "fieldPath": "status", "order": "ASCENDING" },
        { "fieldPath": "createdAt", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "students",
      "fields": [
        { "fieldPath": "branch", "order": "ASCENDING" },
        { "fieldPath": "section", "order": "ASCENDING" },
        { "fieldPath": "yearOfStudy", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "studentScores",
      "fields": [
        { "fieldPath": "displayScore", "order": "DESCENDING" }
      ]
    }
  ]
}
```

---

## 5. MIGRATION PATH

If you want to refactor to the new schema, here's the safe approach:

### Phase 1: Add New Collections (Non-Breaking)
```typescript
// Create studentScores collection in parallel
// Start writing cpScores to BOTH locations:
// 1. students/{studentId}.cpScores (old)
// 2. studentScores/{studentId} (new)
```

### Phase 2: Update Reads
```typescript
// Update queries to read from studentScores
// Keep fallback to students/{studentId}.cpScores
const scores = 
  await studentScoresCol.doc(studentId).get() ||
  (await studentsCol.doc(studentId).get()).data?.cpScores
```

### Phase 3: Remove Duplicate Fields
```typescript
// Remove userId, year, etc. from students doc
// Migrate one student at a time in background job
```

### Phase 4: Deprecate Old Locations
```typescript
// Once >99% migrated, remove old writes
// Keep reads for another release cycle
```

---

## 6. CODE EXAMPLES - CORRECT USAGE

### Reading Student Profile
```typescript
async function getStudentProfile(studentId: string) {
  const studentDoc = await studentsCol.doc(studentId).get();
  const scoresDoc = await studentScoresCol.doc(studentId).get();
  
  return {
    profile: studentDoc.data(),
    scores: scoresDoc.data()
  };
}
```

### Updating Handles & Triggering Refresh
```typescript
async function updateHandlesAndRefresh(studentId: string, handles: CpHandles) {
  const batch = firestore.batch();
  
  // Update handles
  batch.set(studentsCol.doc(studentId), 
    { cpHandles: handles, updatedAt: FieldValue.serverTimestamp() },
    { merge: true }
  );
  
  await batch.commit();
  
  // Trigger refresh asynchronously (don't wait)
  refreshStudentCPData(studentId).catch(err => 
    console.error("Background refresh failed:", err)
  );
}
```

### Leaderboard Query
```typescript
async function getLeaderboard(limit: number = 100) {
  const snapshot = await studentScoresCol
    .orderBy("displayScore", "desc")
    .limit(limit)
    .get();
  
  const scores = snapshot.docs.map(doc => doc.data());
  
  // Enrich with student names
  const enriched = await Promise.all(
    scores.map(async score => ({
      ...score,
      student: (await studentsCol.doc(score.studentId).get()).data()
    }))
  );
  
  return enriched;
}
```

---

## 7. TESTING CHECKLIST

After refactoring:

- [ ] Can student login via Google?
- [ ] Can instructor login via email/password?
- [ ] Does onboarding save all fields correctly?
- [ ] Do scrapers work and save to cpProfiles?
- [ ] Are scores computed correctly?
- [ ] Is leaderboard fast (uses studentScores index)?
- [ ] Can users update their handles?
- [ ] Are timestamps consistent?
- [ ] Can data be queried by branch/section/year?
- [ ] Do old endpoints still work during migration?

---

## 8. SUMMARY OF RECOMMENDATIONS

| Issue | Current | Recommended | Priority |
|-------|---------|-------------|----------|
| Duplicate `year` field | âœ“ | Remove, use only `yearOfStudy` | ðŸ”´ HIGH |
| Redundant `userId` in students doc | âœ“ | Remove (use doc ID) | ðŸ”´ HIGH |
| Mixed auth models (Firebase + custom) | âœ“ | Consistent approach (Option A: Firebase for all) | ðŸŸ¡ MEDIUM |
| Scattered data (users + students + scores) | âœ“ | Separate `studentScores` collection | ðŸŸ¡ MEDIUM |
| Timestamp naming | Inconsistent | `scrapedAt`, `computedAt`, `createdAt`, `updatedAt` | ðŸŸ¢ LOW |
| No soft delete | âœ“ | Add `status` + `deletedAt` fields | ðŸŸ¡ MEDIUM |
| Missing Firestore indexes | Not defined | Create `firestore.indexes.json` | ðŸŸ¡ MEDIUM |
| Score staleness | Not managed | Add `expiresAt` + refresh strategy | ðŸŸ¡ MEDIUM |

This structure will be more maintainable, scalable, and aligned with Firebase best practices.
